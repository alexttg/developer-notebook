# 内存可见性
> 线程之间通信，有主存和工作内存的概念，线程执行的一般三个步骤： 从1、主存读取数据 2、修改数据 3、写回主存。如果有两个线程。A线程执行修改以后不能及时同步到共享内存中， 则对B线程来说，数据是不可见的，如果B线程再试图去操作内存，那么就会产生数据安全问题

###并发编程数据安全出现的原因
1、内存不可见（线程A无法看到线程Bcpu缓存中所修改的内容）

2、cpu不是原子性（同一段逻辑操作cpu会使用不同线程分时复用去执行）

3、无序性（编译器和处理起会对代码进行指令重排，先执行的代码可能后执行）

###JAVA存模型 JMM 
定义了如何在单线程或多线程环境中的线程和硬件之间进行数据的存储和交换。 围绕着在并发过程中如何处理**可见性**、**原子性**、**有序性**这三个特性而建立的模型。


JMM定义了每个线程与中的副本与主内存的关系，每个线程会有单独的副本，从主内存中copy出来存入自己的线程副本中，（在 java 中，所有实例域、静态域和数组元素存储在堆内存中，局部变量，方法参数与异常参数则是存储在线程栈中，并不共享，固不会出现安全问题）

###来看一下一个简易的demo


```
public static int i = 0;

public static void main(String[] args) throws Exception {
    for (int i = 0; i < 10; i++) {
        new Thread(Demo::sum).start();
    }
    Thread.sleep(3000);
    System.out.println(i);
}

private static void sum() {
    while (i < 10000) {
        i++;
    }
}
```
![](https://cdn.nlark.com/yuque/0/2023/png/22527471/1685022991229-36fe7ae7-222c-40c1-9f0d-4ba5e5d67fdb.png)

由于变量i为静态域处于共享内存中，当结果输出10001说明当某个线程去拿到主内存中i变量时，某个线程正在修改自己线程副本中的i变量但是却没有及时同步到主内存中去，并且i++这个操作并不是原子性操作，所以导致其他线程去内存中同步自身线程副本中的数据时拿到了脏数据，造成了线程安全问题，期望值是10000但是输出的结果却是为10001


![](https://foruda.gitee.com/images/1685601063656526701/78908dff_5094274.png)

那么造成变量i输出值为10001的过程大致如下
![](https://foruda.gitee.com/images/1685601101572240362/a51842b4_5094274.png)


### cpu结构


![](https://cdn.nlark.com/yuque/0/2023/png/22527471/1685023407915-d9d31c75-40a8-4691-99ba-9dc7d146473e.png)

###内存不可见带来的影响

下面来看另外一段代码，期望程序运行的结果是线程A与线程B交替执行各50次，然而，该代码段执行的结果可能是执行一次后将永远挂起

```

private  static boolean flag = false;

public static void main(String[] args) {
    new Thread(() -> {
        int num = 1;
        while (num <= 50) {
            if (flag) {
                System.out.println("线程A执行" + num);
                flag = false;
                num++;
            }
        }
    }).start();
    new Thread(() -> {
        int num = 1;
        while (num <= 50) {
            if (!flag) {
                System.out.println("线程B执行" + num);
                flag = true;
                num++;
            }
        }
    }).start();

}
```
![](https://foruda.gitee.com/images/1685601136854763297/298557ce_5094274.png)

由于线程的不可见性线程A与线程B的工作内存并不共享，相对独立，线程A与线程B并不能及时知道对方对主内存的flag变量的任何操作，所以程序运行起来则会造成假死状态 ，Java 内存模型的抽象示意图如下
![](https://foruda.gitee.com/images/1685601174212346886/c14de467_5094274.png)

###volatile 关键字的作用

为了解决如上问题，JDK5开始引入了关键字`volatile`
JSR-133规范中，定义了关键字`volatile`，当被该关键字修饰的变量，线程将会将每一次写的操作都同步到主内存中，`volatile` 每一次写入操作都在读取操作之前，所以volatile也可以是被称作为一种轻量级的锁，他能够保证线程的中的变量是可见的，可以利用这一点去做到线程之间的通信。
那么将上诉代码稍作改动，为了确保对变量i的更新可以传播到其他线程，我们应该将`volatile` 修饰符应用于`i`变量


```
private volatile static boolean flag = false;

public static void main(String[] args) {
    new Thread(() -> {
        int num = 1;
        while (num <= 50) {
            if (flag) {
                System.out.println("线程A执行" + num);
                flag = false;
                num++;
            }
        }
    }).start();
    new Thread(() -> {
        int num = 1;
        while (num <= 50) {
            if (!flag) {
                System.out.println("线程B执行" + num);
                flag = true;
                num++;
            }
        }
    }).start();
}
```

![](https://foruda.gitee.com/images/1685601214457169899/d426dbaa_5094274.png)
如上所述，我们运行时与不同核心处理器进行通信，以不重新排序任何涉及`volatile`变量的指令。此外，处理器会立即刷新对这些变量的任何更新。

![](https://foruda.gitee.com/images/1685601346441168580/12ecbcbf_5094274.png)


`volatile`可以帮助确保数据更改的可见性与避免部分指令重排序，而不提供互斥。因此，它在我们可以允许多个线程并行执行代码块的地方很有用，我们只需要确保可见性

###Long与Double在多线程中的情况
JAVA的内存模型只保证了基本变量的读取操作和写入操作都必须是原子操作的，但是对于64位存储的Long和Double类型来说，JVM读操作和写操作是分开的，分解为2个32位的操作，
如果不做任何处理，当多个线程读取Long变量或Double变量时，可能出现读取这个变量一个值的高32位和另一个值的低32位，从而导致数据的错乱。所以如果要在共享内存中声明Long和Double字段，那么必须在`synchronized`中操作或使用`volatile`做为修饰符
