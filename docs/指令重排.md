##指令重排与Happens-Before
###编译器的优化
举个简单的例子，下面这段代码：

```
public class Test {
    
    public static void main(String[] args) {
        int leng = 0;
        int wid = 0;
        int length = 2;
        int width = 3;
        leng = length;
        wid = width;
        int area = leng * wid;
        System.out.println(area);
    }

}
```
	javap -c Test.class
将代码代码编译出来查看指令集合

```
 public static void main(java.lang.String[]);
    Code:
       0: iconst_2   //将int 2 入栈 
       1: istore_3  //将int 2 存储到第三个变量中
       2: iconst_3  //将int 3 入栈 
       3: istore        4  //将int 3 存储到第四个变量中
       5: iload_3    // 将第三个int 类型变量进栈 也就是 length=2
       6: istore_1  // length=2 放入第一个变量中 leng=length
       7: iload         4  //将int 3 存储到第四个变量中
       9: istore_2   // wid=width;将第四个变量放入第2个变量中
      10: iload_1  // 加载第一个变量
      11: iload_2  // 加载第二个变量
      12: imul   //两者相乘
      13: istore        5
      15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      18: iload         5
      20: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
      23: return
}

```
发现java在编译的过程中会对相关代码的结构作出优化，编译顺序与结构，按照预期的结构应该指令集的前部分应该是

```
   0: iconst_0 //将int 0 入栈 
   1: istore_1 //将int 0 存储到第1个变量中
   2: iconst_0 //将int 0 入栈 
   3: istore_2 //将int 0 存储到第2个变量中
```
 但是实际生成的字节码集合却并不是很符合预期结果，原因是因为在编译过程中，回检查代码的上下文，对其结构进行调整，在代码8、9行中对变量进行了最终赋值，那么jvm将对编译结果进行优化。也就是说编译器会对代码进行重排序。
  
###指令重排有以下规则
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

为了验证其猜想，对上述代码稍做调整，注释8、9行

```
public class Test {

    public static void main(String[] args) {
        int leng = 0;
        int wid = 0;
        int length = 2;
        int width = 3;
//        leng = length;
//        wid = width;
        int area = leng * wid;
        System.out.println(area);
    }

}
```

```
  public static void main(java.lang.String[]);
    Code:
       0: iconst_0 //将int 0 入栈 
       1: istore_1 //将int 0 存储到第1个变量中
       2: iconst_0 //将int 0 入栈 
       3: istore_2 //将int 0 存储到第2个变量中
       4: iconst_2
       5: istore_3
       6: iconst_3
       7: istore        4
       9: iload_1
      10: iload_2
      11: imul
      12: istore        5
      14: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      17: iload         5
      19: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
      22: return
}
```
所以得出结论，我们编写的程序都要经过编译器和处理器优化后才会被运行，优化分为很多种，其中有一种优化叫做重排序，重排序则为了保证优化前与优化后结果具有一致性，则需要遵循Happens-Before规则
###Happens-Before规则

具体具有以下规则

1. 程序顺序规则：在一个线程内，在程序前面的操作先行发生于后面的操作
2. 监视器锁规则：对一个锁的解锁，先行发生于随后对这个锁的加锁。
3. volatile变量规则：对一个volatile域的写，先行发生于任意后续对这个volatile域的读。传递性：如果A happens-before B，且B happens-before C，那么A happens-before C
4. start()规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
5. join()规则：如果线程A执行操作Thread B.join()并成功返回，那么线程B中的任意操作先行发生于线程A从ThreadB.join()操作成功返回。
6. 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
7. 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

**Happens-Before规则 必须要遵循as-if-serial 语义**

不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

```
int leng,wid = 0;
int length = 2; //为了方便说明将该操作称为 A
int width = 3; //为了方便说明将该操作称为 B
int area = leng * wid; //为了方便说明将该操作称为 C
```
如果 

A happens-before B

B happens-before C

A happens-before C （传递性）

如果根据happens-before进行指令重排序，无论 B->A->C还是A->B->C ,执行的结果并不会发生改变，因为只是改变了变量的赋值顺序，JMM 会允许这种重排序

但是如果执行的顺序为C->A->B或者C->B->A时，这种重排序会改变执行结果，所以编译器和处理器会遵循 as-if-serial 语义不会对存在数据依赖关系的

###cpu与操作系统
![](https://foruda.gitee.com/images/1685601623995098609/587d3822_5094274.png)