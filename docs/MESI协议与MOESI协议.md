#MESI协议与MOESI协议
###cpu多核工作方式
CPU执行为了提高效率，会向主内存中同步数据在自己的工作副本中，如下图所示
![](https://foruda.gitee.com/images/1685611797449851461/1f05f8fb_5094274.png)
那么对于每个CPU在处理数据的时候就不免会造成缓存和主存的数据不一致的问题， 为了解决多核cpu缓存不一致造成的数据问，MESI协议与MOESI协议由此诞生，MOESI为MESI的衍生，多了一种状态，效率要远高于MESI协议，现绝大多数 ARM 处理器使用 MOESI 协议，Cortex-A9 则使用 MESI 协议。
###MESI协议
MESI协议主要是四个关键字的缩写

```
M：代表已修改（Modified）

E：代表独占（Exclusive）

S：代表共享（Shared）

I：代表已失效（Invalidated）
```
1. 已修改（Modified）缓存段，属于脏段，已经被所属的处理器修改了。但是还没有写会主内存中，如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中

2. 独占（Exclusive）缓存段，和S状态一样，和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。

3. 共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。
4. 失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。需要重新加载到缓存中，这个是初始状态

**举例说明**：

第一步：当cpu 1 将主内存中的数据x data 放入自身内存副本中，该内存副本的状态为E独占。

第二步：当cpu 2 也将主内存的数据x data 放入自身内存副本中，根据嗅探机制 cpu1与cpu2知道x data数据并不是只有自身一份时，cpu 1与cpu 2内存副本的状态变为S共享。

第三步：当cpu 1修改 x data的数据时候，cpu 1工作副本的状态变为M修改，并通知到 cpu 2 使其状态变为I无效

最后一步：当cpu 1确认除自身所有cpu缓存中都变为I无效状态，便修改后的值刷新到主存中，并将自身 cpu 1的状态变为E独占。
依次往复

###MOESI协议
> MOESI协议与MOESI协议相比多引入了一个O(Owned)状态，并在MESI协议的基础上，进行了重新定义了S状态，而E、M和I状态和MESI协议的对应状态相同。

1. O位。O位为1表示在当前Cache 行中包含的数据是当前处理器系统最新的数据拷贝，而且在其他CPU中一定具有该Cache行的副本，其他CPU的Cache行状态为S。如果主存储器的数据在多个CPU的Cache中都具有副本时，有且仅有一个CPU的Cache行状态为O，其他CPU的Cache行状态只能为S。与MESI协议中的S状态不同，状态为O的Cache行中的数据与存储器中的数据并不一致。

2. S位。在MOESI协议中，S状态的定义发生了细微的变化。当一个Cache行状态为S时，其包含的数据并不一定与存储器一致。如果在其他CPU的Cache中不存在状态为O的副本时，该Cache行中的数据与存储器一致；如果在其他CPU的Cache中存在状态为O的副本时，Cache行中的数据与存储器不一致。
![](https://foruda.gitee.com/images/1685611824384009099/0a19f04a_5094274.png)